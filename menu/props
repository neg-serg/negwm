#!/usr/bin/env python

import subprocess
import re
import socket
import logging
import asyncio
from typing import List
import pickle
import sys
import i3ipc
import i3ipc.con

from negwm.modules.reflection import reflection
from negwm.lib.menu import menu


class props():
    def __init__(self):
        self.delim="@" # Magic delimiter used by add_prop / del_prop routines.
        # create echo server socket
        self.sock=socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
        # negwm which allows add / delete property.
        # For example this feature can be used to move / delete window
        # to / from named scratchpad.
        self.possible_mods=['scratchpad', 'circle']
        # Window properties used by i3 to match windows.
        rules_xprop=['WM_CLASS', 'WM_WINDOW_ROLE', 'WM_NAME', '_NET_WM_NAME']
        self.prompt,self.matching='❯>','fuzzy'
        self.xprops_list=[
            'WM_CLASS', 'WM_NAME', 'WM_WINDOW_ROLE', 'WM_TRANSIENT_FOR',
            '_NET_WM_WINDOW_TYPE', '_NET_WM_STATE', '_NET_WM_PID'
        ]
        self.i3rules_xprop=set(rules_xprop)
        self.i3=i3ipc.Connection()

    def tag_name(self, mod: str, lst: List[str]) -> str:
        """ Returns tag name, selected by menu.
            mod (str): module name string.
            lst (List[str]): list of menu input. """
        params={'prompt': f'{menu.wrap_str(mod)} {self.prompt}'}
        menu_tag=subprocess.run(
            menu.args(params),
            stdout=subprocess.PIPE,
            input=bytes('\n'.join(lst), 'UTF-8'),
            check=False
        ).stdout
        if menu_tag is not None and menu_tag:
            return menu_tag.decode('UTF-8').strip()
        return ""

    async def move_window(self):
        """ Start autoprop menu to move current module to smth. """
        for mod in self.possible_mods:
            if mod is None or not mod:
                return
            aprop_str=self.get_autoprop_as_str(with_title=False)
            echo=reflection.echo
            tag_name=self.tag_name(mod, pickle.loads(await echo(f'{mod} get_config\n')))
            if tag_name is not None and tag_name:
                await reflection.run(f'{mod} add_prop {tag_name} {aprop_str}')
            else:
                logging.error(f'No tag name specified for props {aprop_str}')

    async def unmove_window(self):
        """ Start autoprop menu to move current module to smth. """
        for mod in self.possible_mods:
            if mod is None or not mod:
                return
            echo=reflection.echo
            print(pickle.loads(await echo(f'{mod} get_added_props\n')))
            # mod='circle'
            # stuff=pickle.loads(await echo(f'{mod} get_additional_props\n'))
            # tag_name=self.tag_name(
            #     mod,
            #     pickle.loads(await echo(f'{mod} get_additional_props\n'))
            # )
            # print(tag_name)
            # if tag_name is not None and tag_name:
            #     await reflection.run(f'{mod} del_prop {tag_name} {aprop_str}')
            # else:
            #     logging.error(f'No tag name specified for props {aprop_str}')

    def show_props(self) -> None:
        """ Send notify-osd message about current properties. """
        aprop_str=self.get_autoprop_as_str(with_title=False)
        notify_msg=['notify-send', 'X11 prop', aprop_str]
        subprocess.run(notify_msg, check=False)

    def get_autoprop_as_str(self, with_title: bool=False,
                            with_role: bool=False) -> str:
        """ Convert xprops list to i3 commands format.
            with_title (bool): add WM_NAME attribute, to the list, optional.
            with_role (bool): add WM_WINDOW_ROLE attribute to the list,
            optional. """
        xprops=[]
        win=self.i3.get_tree().find_focused()
        xprop=subprocess.run(
            ['xprop', '-id', str(win.window)] + self.xprops_list,
            stdout=subprocess.PIPE,
            check=False
        ).stdout
        if xprop is not None:
            xprop=xprop.decode('UTF-8').split('\n')
        ret=[]
        for attr in self.i3rules_xprop:
            for xattr in xprop:
                xprops.append(xattr)
                if attr in xattr and 'not found' not in xattr:
                    founded_attr=re.search("[A-Z]+(.*)=", xattr).group(0)
                    xattr=re.sub("[A-Z]+(.*)=", '', xattr).split(', ')
                    if "WM_CLASS" in founded_attr:
                        if xattr[0] is not None and xattr[0]:
                            ret.append(f'instance={xattr[0]}{self.delim}')
                        if xattr[1] is not None and xattr[1]:
                            ret.append(f'class={xattr[1]}{self.delim}')
                    if with_role and "WM_WINDOW_ROLE" in founded_attr:
                        ret.append(f'window_role={xattr[0]}{self.delim}')
                    if with_title and "WM_NAME" in founded_attr:
                        ret.append(f'title={xattr[0]}{self.delim}')
        return "[" + ''.join(sorted(ret)) + "]"

if __name__ == '__main__':
    if len(sys.argv) < 2:
        asyncio.run(props().move_window())
    else:
        if sys.argv[1] == 'show': props().show_props()
        if sys.argv[1] == 'del': asyncio.run(props().unmove_window())
